# 什么是锁
* 锁机制用于管理共享资源的并发访问。
# 锁类型
### 共享锁（S Lock），允许事务读一行数据
### 排他锁（X Lock），允许事务删除或更新一行数据
* 如果一个事务已经获取了行X的共享锁，那么另外一个事务可以立即获取行X的共享锁。因为读取并没有改变行X的数据，成这种情况为**锁兼容（Lock Compatible）**
但若有事务想获取行X的排它锁，则必须等前两个事务释放行X上的共享锁--这种情况称为**锁不兼容**
* Innodb支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁。
* 为了支持在不同粒度上进行加锁操作，Innodb支持另外一种锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定对象分为多个层次
* Innodb其意向锁即为表级别的锁。设计目的：为了在一个事务中揭示下一行将被请求的锁类型。
* 1.意向共享锁（IS Lock），事务想要获取一张表中的某几行的共享锁
* 2.意向排他锁（IX Lock）,事务想要获取一张表中的某几行的排它锁
* 由于Innodb存储引擎支持的是行级锁，因此意向锁不会阻塞除全表扫描以外的任何请求
* 可以通过 show engine innodb status 来查看当前锁请求的信息。
* **一致性非锁定读**
* 指Innodb存储引擎通过行多版本控制的方式读取当前执行时间数据库中的行的数据。如果该读取的行正在进行update、delete操作，这是读取操作不会因此等待上一个锁释放。
相反的，innodb存储引擎会读取行的一个快照数据。
* **一致性锁定读**
* 默认配置，innodb的事务隔离级别为Repeatable Read（重复读），select操作使用一致性非锁定读。默写情况下，需要显式的对数据库的读取进行加锁。
* **两种一致性锁定读**
* 1.select *** for update;
* 对读取的行加X锁，其他事务不能对已锁定的行加上任何锁。
* 2.select *** lock in share mode;
* 对读取的行加S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，会被阻塞。

# 锁的算法
### Record Lock：单个记录上的锁
* 总是会锁住记录索引，如果Innodb存储引擎表在建表的时候没有设置任何一个索引，则会使用隐式的主键来锁定。
### Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。
### Next-Key Lock：Gap Lock+Record Lock，锁定一个范围并包含记录本身
* Innodb采用next-key locking算法避免幻读，select * from table where a>2 for update;是对2~无穷大这个范围加了X锁。不允许在这个范围内插入

# 锁问题
* 脏读，指事务对缓冲池中的行记录进行修改，并还没有提交。一个事务可以读取另一个事务未提交的数据，违反了数据库的**隔离性**
* 不可重复度，在一个事务中多次读取同一数据集不同。
* 丢失更新，一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据不一致。如两个事务同时读取了同一个余额100，a事务修改了值提交后，b事务也修改了（但是b事务还是在100的基础上修改）
* 解决数据丢失更新，在两个事务读取的时候加X锁

# 阻塞
* 一个事务中的锁需要等待另一个事务中的锁释放他所占用的资源。
* Innodb存储引擎中，参数innodb_lock_wait_timeout（默认50s)来控制等待的时间。innodb_rollback_on_timeout用来设定是否在等待超时后对事务进行回滚操作，（默认off，不回滚）

# 死锁
* 指两个或两个以上的事务在执行的过程中，因争夺资源而造成的一种互相等待的现象。
* 解决死锁：超时。超时后，其中一个事务回滚，另一个等待事务就能继续。
* wait-for graph（等待图）的方式进行死锁检测。Innodb采用的也是这种方式。
* wait-for graph要求数据库保存以下两种信息：
* 1.锁的信息链表
* 2.事务等待链表
* wait-for graph是一种较为主动的死锁检测机制。在每个事务请求锁并发生等待是都会判断是否存在回路，若存在则有死锁。通常，innodb会选择回滚undo量最小的事务。

# 锁升级（Lock Escalation）
* 指将当前锁的粒度降低。
