# Innodb索引概述
### B+数索引
* B+树索引最早是由平衡二叉树演变而来，但是B+树不是一个二叉树。
* 并不能B+树索引找到具体的行，而是根据B+树索引找到行所在的页，然后数据库把页中的数据读到内存中，再在内存中进行查找。
* 数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。
但是不论是聚集索引还是辅助索引，其内部都是B+树，即高度平衡的。叶子节点放着所有的数据。不同的是叶子节点存放的是否是一整行的信息。
* **聚集索引**
* 1.聚集索引（clustered index）是按照主键构造一颗B+树，同事叶子节点存放的是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。
* 2.由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。
* **辅助索引**
* 1.对于辅助索引（Secondary index）也称非聚集索引，叶子节点并不包含行记录的全部信息。
* 2.叶子节点除了包含键值以外，每个叶子节点的索引行中还包含一个书签（bookmark）。该书签用来告诉innodb存储引擎哪里可以找到与索引对应的行数据。
* 3.当通过非聚集索引来查找数据时，Innodb存储引擎会遍历辅助索引，并通过叶级别的指针获得指向主键索引的主键。然后再通过主键索引来找到一个完整的行记录。
* **B+树索引的管理**
* 1.索引的创建和删除可以通过两种方法，一种是alter table，另一种是Create/Drop index
* 2.show index；中展示的值：Collation（列以什么方式存储在索引中），可以使A或者NULL。B+索引总是A，即排序的。如果使用Heap存储引擎，并建立了Hash索引，就会显示NULL
Cardinality(**关键的值**，表示索引中唯一值的数目的估计值。尽可能接近1，如果非常小，可以考虑删除此索引)
Sub_part(是否是列的部分被索引。如果是整个列，显示NULL，否者显示多少列被索引)
Index_type(索引的类型，Innodb存储引擎只支持B+树索引，所以这里显示的都是BTree)。
* 3.Cardinality并非每次索引更新都会更新该值，如果要手动更新可以使用 analyze table 命令
* **Fast index creation**
* mysql5.5之前，存在一个普通被人诟病的问题是：mysql数据库对索引的添加或删除这类DDL操作，过程为：
* 1.首先创建一张临时表，表结构通过命令alter table新定义的结构。
* 2.然后把原来表的数据导入到临时表
* 3.删除原表
* 4.最后把临时表名改为原来表名。
* Innodb从1.0.x版本开始支持一种称为Fast index creation（快速索引创建）的索引创建方式，简称（FIC）
* 对于辅助索引的创建，Innodb会对创建索引的表加一个S锁。在创建过程中，不需要重建表。删除索引，只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除Mysql数据库内部视图上对该表的索引定义即可。
* FIC只限定于辅助索引，对主键的创建删除同样需要重建一个表。
* **Online Schema Change**（在线架构改变 OSC）
* **Online DDL**
### Cardinality值
* 表示索引中不重复记录数量的预估值，其是一个预估值，而不是一个准确的值
* 实际应用中，Cardinality/n_rows_in_table	应尽可能接近1
* Cardinality是怎么统计的？策略是：
* 1.表中1/16的数据已发生过变化。
* 2.start_modified_counter>2 000 000 000
### B+索引的使用
* **联合索引**
```
table 中有字段id，value，time，有索引 value,value_time
select * from table where value='xxx';//命中索引value
select * from table where value='xxx' order by time desc;//命中value_time
```
* **覆盖索引**
* 如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作
* Innodb支持覆盖索引（covering index），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。
* 使用覆盖索引的一个好处是辅助索引不包含整行的记录的所有信息，故其大小要远小于聚集索引。因此可以减少大量的IO操作。
* 当发起一个被索引覆盖的查询时，在explain的Extra列可以看到 Using index的标识
### 全文索引
* 全文索引（Full-Text Search）是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。
* 从innodb1.2.x开始，innodb开始支持全文索引，其支持MyIsam存储引擎的全部功能，并且还支持一些其他特性。
* 全文索引一般通过倒排索引（inverted index）来实现。倒排索引同B+树索引一样，也是一种索引结构。他在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置的映射
* 1.inverted file index，其表现形式为{单词，单词所在文档ID}
* 2.full inverted index,其表现形式为{单词，（单词所在文档ID，再具体文档中的位置）}
* full inverted index所占用的空间更多，但是能更好的定位数据。
* **Innodb全文检索**
* 从innodb1.2.x开始支持全文检索技术，采用full inverted index方式。
* 限制
* 1.每张表只能有一个全文索引的索引
* 2.由多列组成的全文索引必须使用相同的字符集与排序规则
* 3.不支持没有单词界定符（delimiter）的语言。如中文、日文、韩语等
* **全文检索**
```
select * from fts_a where match(body) against ('Porridge' IN NATURAL LANGUAGE MODE);
```
* 在where条件中使用Match函数，查询结果是根据相关性进行降序排序的，即相关性最高的放在第一位。
* 计算相关性四个条件
* 1.word是否在文档中出现
* 2.出现的次数
* 3.在索引列的数量
* 4.多少个文档包含word
* **全文索引还有其他的**

### hash索引
* Innodb存储引擎支持的hash索引是自适应的，Innodb存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成hash索引
* **哈希表**
* 哈希表（Hash Table）也称为散列表，由直接寻址表改进而来。
* hash表技术很好的解决了直接寻址遇到的问题。
* Innodb存储引擎使用哈希算法对字典进行查找，其冲突机制采用链表方式，hash函数采用除法散列方式。
* 自适应hash索引采用之前讨论的哈希表的方式实现。不同的是，这仅是数据库自身创建并使用的，DBA本身并不能对其进行干预。
* hash索引只针对搜索等值的查询，对范围查找不起作用。
