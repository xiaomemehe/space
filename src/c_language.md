# 目录
* link from : https://mp.weixin.qq.com/s/lzm3dm5tSGYmhrJK4kiUJg

### 数据的表现形式
* 常量和变量：
1. 常量
2. 变量
3. 常变量：在变量的基础上只是不能修改
4. 标识符

* 基本数据类型

|标识|表示|类型|字节|
|:-|:-|:-|:-|
|int|基本整型|整型类型|2/4|
|short int|短整型|整型类型|2|
|long int|长整型|整型类型|4|
|long long int|双长整型|整型类型|8|
|char|字符型|整型类型|1|
|bool|布尔型|整型类型||
|float|单精度浮点型|浮点类型|4|
|double|双精度浮点型|浮点类型|8|
|float_comlex|复数浮点型|浮点类型||
|double_comple|复数浮点型|浮点类型||
|long long_comple|复数浮点型|浮点类型||
|enum|枚举类型|枚举类型||
|void|空类型|空类型||
|*|指针类型|派生类型||
|[]|数组类型|派生类型||
|struct|结构体类型|派生类型||
|union|共用体类型|派生类型||
|函数|函数类型|派生类型||

* 在一个整型后面加上l/L，表示为长整型

### 运算符和表达式
* 字符型数据与整型数据进行运算，就是把字符的ASCII代码与整数数据进行运算。
* 强制类型转换：（int）a

### 语句
* 赋值过程中的类型转换
* 字符型数据赋给整型变量时，将字符的ASCII代码赋给整型变量
* 将一个字节占用多的整型数据赋给yi个占字节少的的整型变量或字符变量时，只将其低字节原封不动的复制过去。
```

1个字节 -128~127

code：
	# include <stdio.h>
	int main(void)
	{
	    int i;
	    scanf("%d", &i);
	    int il = sizeof(i);
	    printf("i = %d size=%d\n", i, il);
	    char j;
	    j = i;

	    int jl = sizeof(j);
	    printf("j = %d size=%d\n", j, jl);
	    return 0;
	}

result:
	bash-3.2$ gcc -o _int.out _int.c
	bash-3.2$ ./_int.out
	i = 128 size=4
	j = -128 size=1
	bash-3.2$ ./_int.out
	i = 127 size=4
	j = 127 size=1

说明：大字节转为小字节，保留低字节的。如int i 值为128时转为char（最大127），变为127的下一位，即-128

```

### 数据的输出/输入
* 输出一般格式为：printf（格式控制《一般%号开头》，输出表列《可以是常量，变量，表达式》）
* 格式控制: 
1. d 有符号的十进制整数
2. c 输出字符
3. s 字符串
4. f 浮点数
5. e 指定以指数形式输出实数
* 输入一般格式为：scanf（格式控制，地址表列）

* 同printf，地址表由若干个地址组成的表列，可以是变量的地址，或者字符串的首地址
* 注意是地址，而不是变量

### 字符数据的输出/输入
* char a = getchar();
* putchar（c）中的c可以是字符常量、整型常量、字符变量或整型变量。

### if语句

### 关系运算符和表达式

### 逻辑运算符和表达式

### 条件运算符和表达式
* 条件运算符优先于赋值运算符
* 三目运算符:表达式1？表达式2：表达式3

### 选择的嵌套和switch

### while

### do{}while

### for

### 数组（一维、二维、字符）
* 一维数组一般形式：类型符 数组名[常量表达式]
* 在定义数组并对其中各元素赋值后，就可以引用数组中的元素。
* 应该注意的是，只能引用数组元素而不能一次整体调用整个数组全部元素的值。
* 如果在定义数值型数组时，指定了数组的长度并对之初始化，凡未被“初始化列表”指定初始化的数组元素，系统会自动把它们初始化为0。
* 如果是字符型数组，则初始化为'\0'，如果是指针型数组，则初始化为null，即空指针。

* 二维数组定义：类型说明符 数组名[常量表达式][常量表达式]

* 字符数组的定义：用来存放字符数据的数组是字符数组。**字符数组中的一个元素存放一个字符。** char c[10];
* C语言中，是将字符串作为字符数组来处理的，字符串是逐个存放到数组元素中。
* 为了测定字符串的实际长度，C语言规定了一个“字符串结束标识”，以字符“\0”作为结束标识
* ‘\0’代表ASCII码为0的字符
* 字符数组并不要求它的最后一个字符为'\0'，甚至可以不包含'\0'
* 如果数组长度大于字符串的实际长度。也只输出到遇“\0”结束。
* **字符串处理函数**注意


### 函数（定义、调用、数组作为参数）
* 用户角度：函数分为库函数、自定义函数
* 函数形式：无参函数、有参函数
```
无参函数：
	类型名 函数名(){

	}
	或者
	类型名 函数名(void){

	}
有参函数：
	类型名 函数名(形参列表){

	}

```

* 函数调用：在定义函数中指定的形参，在未出现函数调用时，它们并不是占内存中的存储单元。
* 调用结束，形参单元被释放
* 实参向形参传递是”值传递“

* **数组（元素）作为参数和数组名作为参数**
* 1.数组元素作为实参，是进行值传递，
* 2.使用数组名传递，向形参传递的是数组首元素的地址
* 3.用数组名作为参数时，应该在主调函数和被调函数分别定义数组。
* 4.形参数组可以不指定大小，在定义数组时在数组名后面跟一个指针变量，用来接收一个地址
* **直接传递数组就是传递一个地址指针**
* 参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上

### 局部、全局变量
* 在函数内定义的变量是局部变量，而在函数之外定义的变量称为外部变量，外部变量是全局变量
* 全局变量的有效范围为从定义变量的位置开始到本源文件结束。
* 为了便于区别全局变量和局部变量，在C程序设计人员中有一个习惯，将全局变量的第1个字母用大写表示（非规定）。

### 变量的存储方式和生命周期
* 内存中供用户使用的存储空间分为三种：程序区、静态存储区、动态存储区。
* 存储方式：静态存储、动态存储
* 静态存储：在程序运行期间由系统分配固定的存储空间的方式。
* 动态存储：在程序运行期间进行动态的分配存储空间的方式。
* 全局变量放在了静态存储中，在程序开始时分配，执行完毕后释放。
* 动态存储主要有：
* 1.函数的形参
* 2.函数中没有使用关键字 static 定义的变量，即自动变量
* 3.函数调用是的现场保护和返回地址等。

* 局部变量类别：
* 1.自动变量（auto变量，普通变量）
* 2.静态局部变量（static局部变量），不随着函数调用结束而消失，下一次调用该函数时，该变量已有值。
* 3.寄存器变量（register变量），将局部变量的值放在CPU中的寄存器中，比内存还快

* 全局变量类别：
* 在一个文件内扩展外部变量的作用域，如果由于某种考虑，在定义点之前的函数需要引用该外部变量，则应该在引用之前用关键字extern对该变量作“外部变量声明”，表示把该外部变量的作用域扩展到此位置。

### 内部、外部函数
* 在声明部分出现的变量有两种情况：一种是需要建立存储空间的，另一种是不需要建立存储空间的。前者称为定义性声明，简称定义；后者称为引用性声明。
* 一般为了叙述方便，把建立存储空间的声明称定义，而把不需要建立存储空间的声明称为声明。
* 在函数中出现的对变量的声明（除了用extern声明的以外）都是定义。在函数中对其他函数的声明不是函数的定义。

* 内部函数：
* 一个函数只能被本文件中其他函数所调用，它称为内部函数。定义格式：static 类型名 函数名（形参表）；
* 内部函数又称为静态函数，因为它是用static声明的。

* 外部函数：
* 在定义函数时，在函数首部的最左端加关键字extern，则此函数是外部函数，可供其他文件调用。
* extern int fun（int a,int b）；不带extern的函数默认为外部函数

### 指针
* 一个变量的地址称为该变量的指针
* 如果有一个变量专门用来存放另一变量的地址，则它称为指针变量。
* 指针变量就是地址变量，用来存放地址，指针变量的值是地址

### 指针变量
* 指针变量定义: 类型名 \*指针变量名；//\为转义
* 类型名为指针指向变量的类型
* 一个变量的指针有两个方面:1.存储单元编号表示的地址 2.指向存储单元的类型
* &取地址运算符。&a是变量a的地址。
* \*指针运算符，\*p代表指针变量p指向的对象


### 通过指针引用数组
* 在C语言中，数组名（不包括形参数组名，形参数组并不占据实际的内存单元）代表数组中首元素的地址。
* 当指针指向数组元素时，譬如，指针变量p指向数组元素a[0]，我们希望用p+1表示指向下一个元素a[1]。
```

	void test4(){
		short int a[3] = {1,2,3};
		printf("a is %d\n", a[0]);
		short int *p;
		p = &a[0];
		printf("%d\n", *p);
		printf("address %p\n", p);
		p++;
		printf("%d\n", *p);
		printf("address %p\n", p);
		p++;
		printf("%d\n", *p);
		printf("address %p\n", p);
	}
	a is 1
	1
	address 0x7ffee1fa3a0a
	2
	address 0x7ffee1fa3a0c
	3
	address 0x7ffee1fa3a0e

	void test4(){
		int a[3] = {1,2,3};
		printf("a is %d\n", a[0]);
		int *p;
		p = &a[0];
		printf("%d\n", *p);
		printf("address %p\n", p);
		p++;
		printf("%d\n", *p);
		printf("address %p\n", p);
		p++;
		printf("%d\n", *p);
		printf("address %p\n", p);
	}

	a is 1
	1
	address 0x7ffee6f7d9fc
	2
	address 0x7ffee6f7da00
	3
	address 0x7ffee6f7da04

```
* 上面可以看出，数组的每个元素大小和类型有关，int相差4个字节，short int相差2字节

### 通过指针引用字符串
* 在C程序中，字符串是存放在字符数组中的。

* 字符串作为参数
```

code:
	void test5(){
		char s[10]={"helloworld"};
		test51(s);
		
	}
	int test51(char p[1]){
		printf("%s\n", p);
		return 0;
	}
result :
	helloworld

```

* 字符串作为参数的指针传递 
```

code:
	int test51();
	void test5(){
		char s[10]={"helloworld"};
		char *p = &s[0];
		test51(p);
	}
	int test51(char *p){
		printf("%c\n", *p);
		p++;
		printf("%c\n", *p);
		p++;
		p++;
		p++;
		printf("%c\n", *p);
		return 0;
	}
result :
	h
	e
	o

```
* 形参接受数组大小 不影响接受的结果

* 字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第1个字符的地址），绝不是将字符串放到字符指针变量中。
* 指针变量的值是可以改变的，而数组名代表一个固定的值（数组首元素地址），不能改变。

* 字符数组中各元素的值是可以改变的，但字符指针变量指向的字符串常量中的内容时不可以被取代的。
```
字符串常量是存在静态内存区的，不可以改变的
char* a="i love you.";
a[3]='p'(非法操作)。

char a[]="i love you.";
a[3]=‘p’是可以的.

```

### 指针小结
* 首先要准确的弄清楚指针的含义，指针就是地址，凡是出现“指针”的地方，都可以用“地址”代替，变量的指针就是变量的地址，指针变量就是地址变量
* 要区别指针和指针变量，指针变量的值是一个地址。

### 指针数组和多重指针
* 一个数组，若其元素均为指针类型数据，称为指针数组，也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量。
* 一般形式：类型名 \*数组名[数组长度]；
```
	3、例子

	int *p[4]；

	4、由于[]比*优先级高，因此p先和[4]结合，形成p[4]形式，这显然是数组形式，表示p数组有4个元素。然后再和p前面的*结合，*表示此数组是指针类型的，每个数组元素都可以指向一个整型变量。

```
* 定义一个指向指针数据的指针变量：char \*\*p , \*\*p相当于\*（\*p)
* 

### 动态内存分配和指向他的指针变量
* 全局变量是分配在内存中的静态存储区的，非静态的局部变量（包括形参）是分配在内存中的动态存储区的，这个存储区是一个“栈”的区域
###### 堆啊
* **C语言允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明部分定义，也不必等到函数结束时才释放，而是需要时随时开辟，不需要时随时释放。这些数据是临时存放在一个特别的自由存储区，称为“堆”。**
* 怎么建立内存的动态分配
* 1.malloc
```
函数原型：void *malloc（unsigned int size）；

其作用是在内存的动态存储区分配一个长度为size的连续空间。形参size的类型定为无符号整型。此函数是一个指针型函数，返回的指针指向该分配域的开头位置。
```
* 2.calloc
```
函数原型：void *calloc（unsigned n，unsigned size）；

其作用是在内存的动态存储区中分配n个长度为size的连续空间，这个空间一般比较大，足以保存一个数组。
```
* 3.free
```
函数原型：void free（void *p）；

其作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。
```
* 4.realloc
```
函数原型：void *realloc（void *p，unsigned int size）；

如果已经通过malloc函数或者calloc函数获得了动态空间，想改变其大小，可以用realloc函数重新分配。
```
* C99标准把意思malloc、calloc、realloc函数的基类型定为void类型，这种指针称为无类型指针。

### 定义和使用结构体变量
* 一个结构体变量中可以存放一组有关联的数据
* 整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似
```

struct{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在小组
    float score;  //成绩
} stu1, stu2 = { "Tom", 12, 18, 'A', 136.5 };

```

### 使用结构体数组
* 定义结构体**数组**
```
	struct 结构体名
	{
		成员表列
	}数组名[数组长度]；
```
```
示例代码：
	void test6(){
		struct stru
		{
			int age;
			char name[20];
		};
		char abc[] = "abc";
		struct stru u1[3];//u1为结构体数组
		u1[0].age = 1;
		strcpy(u1[0].name, abc);//对字符传进行赋值，不能用=  ，切记字符串是数组形式
		u1[1].age = 2;
		strcpy(u1[1].name, "bbb");
		u1[2].age = 3;
		strcpy(u1[2].name, "xxx");
		struct stru *p;
		p = &u1[0];
		printf("%s\n", (p++)->name);
		printf("%s\n", (p)->name);

	}
```

### 结构体指针
* 指向结构体对象的指针变量既可以指向结构体变量，也可指向结构体数组中的元素
* C语言中允许把（\*p）.num用p->num来代替，“->”代表一个箭头，p->num表示p所指向的结构体变量中的num成员。
```
	void test6(){
		struct stru
		{
			int age;
			char name[8];
		};
		struct stru u1[2]={{1,"xxx"},{2,"bbb"}};
		struct stru *p=u1;//这里使用  p = &u1[0];  效果一样
		printf("%s\n", (p++)->name);//xxx
		printf("%s\n", p->name);//bbb
	}

1、（++p）->num，先使p自加1，然后得到p指向的元素中的num成员值。

2、（p++）->num，先求的p->num的值，然后再使p自加1。



```

### 链表
* 链表有一个“头指针”变量，它存放一个地址，该地址指向一个元素。
* 链表每个元素称为结点，每个结点有两个部分：1.数据 2.下一个节点指针
* 链表中的地址可以是不连续的

### 共用体 union
```
union 共用体名
{
	成员表列
}变量表列；
```
* 结构体变量所占内存长度是各成员占的内存长度之和。每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员的长度
* 可以对共用体变量初始化，但初始化表中只能有一个常量
* 共用体变量的地址和它的各成员的地址都是同一地址。
* 不能对共用体变量名赋值，也不能企图引用变量名来得到一个值

### 枚举类型
* enum[枚举名]{枚举元素列表}，其中枚举名应遵循标识符的命名规则
* C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为他们是标识符而把他们看作变量，不能对他们赋值。

### 用typedef声明新的类型名
* 简单地用一个新的类型名代替原有的类型名
* typedef int Integer；//指定用Integer为类型名，作用与int相同。
* 

### C文件有关基本知识
* 文件有不同的类型，在程序设计中，主要用到两种文件  1.程序文件  2.数据文件
* 1. 程序文件。包括源程序文件（后缀为.c）、目标文件（后缀为.obj）、可执行文件（后缀为.exe）等。这种文件的内容时程序代码。
* 2.数据文件。文件的内容不是程序，而是供程序运行时读写的数据，如在程序运行过程中输出到磁盘（或其他外部设备）的数据，或在程序运行过程中供读入的数据。

### 打开与关闭文件
* fopen
* fclose

### 顺序读写文件
* 怎样向文件读写字符
```

	1、fgetc函数

	调用形式：fgetc（fp）

	功能：从fp指向的文件读入一个字符。

	返回值：读成功，带回所读的字符，失败则返回文件结束标志EOF（即-1）。

	2、fputc函数

	调用形式：fputc（ch，fp）

	功能：把字符ch写到文件指针变量fp所指向的文件中。

	返回值：输出成功，返回值就是输出的字符；输出失败，则返回EOF（即-1）。

```
* 怎样向文件读写一个字符串
```

	1、fgets函数

	调用形式：fgets（str，n，fp）

	功能：从fp指向的文件读入一个长度为（n-1）的字符串，存放到字符数组str中。

	返回值：读成功，返回地址str，失败则返回NULL。

	2、fputs函数

	调用形式：fputs（str，fp）

	功能：把str所指向的字符串写到文件指针变量fp所指向的文件中。

	返回值：输出成功，返回0；否则返回非0值。

```
* 用格式化的方式读写文件
```

	1、对文件进行格式化输入输出时，要用fprintf函数和fscanf函数，作用与printf函数和scanf函数相仿，都是格式化读写函数。

	2、一般形式

	fprintf（文件指针，格式字符串，输出表列）；

	fscanf（文件指针，格式字符串，输入表列）；

```
* 用二进制方式向文件读写一组数据
```

	1、C语言允许用fread函数从文件中读一个数据块，用fwrite函数向文件写一个数据块。

	2、一般形式

	fread（buffer，size，count，fp）；

	fwrite（buffer，size，count，fp）；

	buffer：是一个地址。

	size：要读写的字节数。

	count：要读写多少个数据项（每个数据项长度为size）。

	fp：FILE类型指针。

```

### 随机读写文件
* 对流式文件既可以进行顺序读写，也可以进行随机读写。关键在于控制文件的位置标记
```

	6、文件位置标记的定位

	可以强制使文件位置标记指向人们指定的位置。

	（1）用rewind函数使文件位置标记指向文件开头。

	rewind函数的作用是使文件位置标记重新返回文件的开头，此函数没有返回值。

	（2）用fseek函数改变文件位置标记

	调用形式：fseek（文件类型指针，位移量，起始点）

	起始点用0、1或2代替，0代表文件开始位置，1为当前位置，2为文件末尾位置。位移量指以起始点为基点，向前移动的字节数。位移量应是long型数据。

	（3）用ftell函数测定文件位置标记的当前位置

	ftell函数的作用是得到流式文件中文件位置标记的当前位置。

```

### 文件读写出错检测
* ferror
* clearerr
